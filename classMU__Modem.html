<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MU_Modem: MU_Modem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MU_Modem
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classMU__Modem-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MU_Modem Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides an interface to control the MU FSK modem.  
 <a href="classMU__Modem.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MU__Modem_8h_source.html">MU_Modem.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MU_Modem:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMU__Modem.png" usemap="#MU_5FModem_map" alt=""/>
  <map id="MU_5FModem_map" name="MU_5FModem_map">
<area href="classSerialModemBase.html" title="Base class handling low-level serial I/O, debugging, and async transaction logic." alt="SerialModemBase" shape="rect" coords="0,0,114,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69f83020f2ccc23ce5601003b34269e8"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a69f83020f2ccc23ce5601003b34269e8">begin</a> (Stream &amp;pUart, MU_Modem_FrequencyModel frequencyModel, MU_Modem_AsyncCallback pCallback=nullptr)</td></tr>
<tr class="memdesc:a69f83020f2ccc23ce5601003b34269e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the modem driver.  <br /></td></tr>
<tr class="separator:a69f83020f2ccc23ce5601003b34269e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093205206ee7f99b2cb8a7acb082e6f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a093205206ee7f99b2cb8a7acb082e6f5">Work</a> ()</td></tr>
<tr class="memdesc:a093205206ee7f99b2cb8a7acb082e6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main processing loop (Delegates to <a class="el" href="classSerialModemBase.html#a6379a71afa895ca5a974e67cfecae4ce" title="Main processing loop. Must be called frequently. Handles command queue, transmission,...">SerialModemBase::update</a>).  <br /></td></tr>
<tr class="separator:a093205206ee7f99b2cb8a7acb082e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75244d356cac51e2d1f13bc86d7265f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ad75244d356cac51e2d1f13bc86d7265f">setPacketBuffer</a> (uint8_t *buf, uint8_t size)</td></tr>
<tr class="memdesc:ad75244d356cac51e2d1f13bc86d7265f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an external buffer to store received packets for <a class="el" href="classMU__Modem.html#a0eaa8ef00883621cd07458fb080ed1a0" title="Checks if a data packet has been received and is buffered (Legacy mode).">HasPacket()</a>/GetPacket(). Not required if using Async Callback only.  <br /></td></tr>
<tr class="separator:ad75244d356cac51e2d1f13bc86d7265f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4073269482792c7909eb3f063e92328e"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a4073269482792c7909eb3f063e92328e">TransmitData</a> (const uint8_t *pMsg, uint8_t len, bool useRouteRegister=false)</td></tr>
<tr class="memdesc:a4073269482792c7909eb3f063e92328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a data packet (Synchronous/Blocking). Queues the command and waits for completion. Checks for LBT error (*IR=01) for a short period after command acceptance.  <br /></td></tr>
<tr class="separator:a4073269482792c7909eb3f063e92328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6631e32d207b6855fe2a8e48b20ad988"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a6631e32d207b6855fe2a8e48b20ad988">TransmitDataAsync</a> (const uint8_t *pMsg, uint8_t len, bool useRouteRegister=false)</td></tr>
<tr class="memdesc:a6631e32d207b6855fe2a8e48b20ad988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a data packet (Asynchronous/Non-blocking). Queues the command and returns immediately. Completion result (TxComplete/TxFailed) is notified via callback.  <br /></td></tr>
<tr class="separator:a6631e32d207b6855fe2a8e48b20ad988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bb2018225a6207d8a774eb5ce1220c"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a53bb2018225a6207d8a774eb5ce1220c">SetBaudRate</a> (uint32_t baudRate, bool saveValue)</td></tr>
<tr class="memdesc:a53bb2018225a6207d8a774eb5ce1220c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the UART baud rate of the modem. The change is applied immediately after the modem sends its response.  <br /></td></tr>
<tr class="separator:a53bb2018225a6207d8a774eb5ce1220c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7eba13080e003515573911fcf5dc72"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a6b7eba13080e003515573911fcf5dc72">SetChannel</a> (uint8_t channel, bool saveValue)</td></tr>
<tr class="memdesc:a6b7eba13080e003515573911fcf5dc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the frequency channel.  <br /></td></tr>
<tr class="separator:a6b7eba13080e003515573911fcf5dc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f55aebc00f928d3dc800f15647bf35f"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a5f55aebc00f928d3dc800f15647bf35f">GetChannel</a> (uint8_t *pChannel)</td></tr>
<tr class="memdesc:a5f55aebc00f928d3dc800f15647bf35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current frequency channel.  <br /></td></tr>
<tr class="separator:a5f55aebc00f928d3dc800f15647bf35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6670c9ecc6d112775659a57f6b47c39"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ae6670c9ecc6d112775659a57f6b47c39">SetPower</a> (uint8_t power, bool saveValue)</td></tr>
<tr class="memdesc:ae6670c9ecc6d112775659a57f6b47c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transmission power.  <br /></td></tr>
<tr class="separator:ae6670c9ecc6d112775659a57f6b47c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92d5ebc0102fb13cea3196a6f488617"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ac92d5ebc0102fb13cea3196a6f488617">GetPower</a> (uint8_t *pPower)</td></tr>
<tr class="memdesc:ac92d5ebc0102fb13cea3196a6f488617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current transmission power setting.  <br /></td></tr>
<tr class="separator:ac92d5ebc0102fb13cea3196a6f488617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d2dcbd26f5e78f8a831875124bfaa4"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a76d2dcbd26f5e78f8a831875124bfaa4">SetDestinationID</a> (uint8_t di, bool saveValue)</td></tr>
<tr class="memdesc:a76d2dcbd26f5e78f8a831875124bfaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Destination ID.  <br /></td></tr>
<tr class="separator:a76d2dcbd26f5e78f8a831875124bfaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e447bf28d31672759cae02660bbccf7"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a6e447bf28d31672759cae02660bbccf7">GetDestinationID</a> (uint8_t *pDI)</td></tr>
<tr class="memdesc:a6e447bf28d31672759cae02660bbccf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current Destination ID.  <br /></td></tr>
<tr class="separator:a6e447bf28d31672759cae02660bbccf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a1f04cce8a4ec97c5630f799197829"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ac0a1f04cce8a4ec97c5630f799197829">SetEquipmentID</a> (uint8_t ei, bool saveValue)</td></tr>
<tr class="memdesc:ac0a1f04cce8a4ec97c5630f799197829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Equipment ID.  <br /></td></tr>
<tr class="separator:ac0a1f04cce8a4ec97c5630f799197829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e842dfdf35828a83be18b53074d3029"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a0e842dfdf35828a83be18b53074d3029">GetEquipmentID</a> (uint8_t *pEI)</td></tr>
<tr class="memdesc:a0e842dfdf35828a83be18b53074d3029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current Equipment ID (Own ID).  <br /></td></tr>
<tr class="separator:a0e842dfdf35828a83be18b53074d3029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf73a7d66cebcfecc6c1a1f3705cefdc"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#acf73a7d66cebcfecc6c1a1f3705cefdc">SetGroupID</a> (uint8_t gi, bool saveValue)</td></tr>
<tr class="memdesc:acf73a7d66cebcfecc6c1a1f3705cefdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Group ID.  <br /></td></tr>
<tr class="separator:acf73a7d66cebcfecc6c1a1f3705cefdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78065dc4a20ad3c5cc33bc9dc9404b21"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a78065dc4a20ad3c5cc33bc9dc9404b21">GetGroupID</a> (uint8_t *pGI)</td></tr>
<tr class="memdesc:a78065dc4a20ad3c5cc33bc9dc9404b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current Group ID.  <br /></td></tr>
<tr class="separator:a78065dc4a20ad3c5cc33bc9dc9404b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a3911d2ae1d8a2746c84b6e772091a"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#af2a3911d2ae1d8a2746c84b6e772091a">SetRouteInfoAddMode</a> (bool enabled, bool saveValue)</td></tr>
<tr class="memdesc:af2a3911d2ae1d8a2746c84b6e772091a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the route info add mode setting.  <br /></td></tr>
<tr class="separator:af2a3911d2ae1d8a2746c84b6e772091a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939cecd600fc9617c796620a1e321827"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a939cecd600fc9617c796620a1e321827">GetRouteInfoAddMode</a> (bool *pEnabled)</td></tr>
<tr class="memdesc:a939cecd600fc9617c796620a1e321827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the route info add mode setting.  <br /></td></tr>
<tr class="separator:a939cecd600fc9617c796620a1e321827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f7989b9881a44f478ea4f3866e6042"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a02f7989b9881a44f478ea4f3866e6042">SetAutoReplyRoute</a> (bool enabled, bool saveValue)</td></tr>
<tr class="memdesc:a02f7989b9881a44f478ea4f3866e6042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the auto reply route setting.  <br /></td></tr>
<tr class="separator:a02f7989b9881a44f478ea4f3866e6042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd689f0e43071d63f4fcd91dcf083bda"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#acd689f0e43071d63f4fcd91dcf083bda">GetAutoReplyRoute</a> (bool *pEnabled)</td></tr>
<tr class="memdesc:acd689f0e43071d63f4fcd91dcf083bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the auto reply route setting.  <br /></td></tr>
<tr class="separator:acd689f0e43071d63f4fcd91dcf083bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add62e145605088cd858a71b523f92bba"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#add62e145605088cd858a71b523f92bba">SetRouteInfo</a> (const uint8_t *pRouteInfo, uint8_t numNodes, bool saveValue)</td></tr>
<tr class="memdesc:add62e145605088cd858a71b523f92bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the relay route information.  <br /></td></tr>
<tr class="separator:add62e145605088cd858a71b523f92bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061c292c53a9836c58940100b10e2c85"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a061c292c53a9836c58940100b10e2c85">GetRouteInfo</a> (uint8_t *pRouteInfoBuffer, size_t bufferSize, uint8_t *pNumNodes)</td></tr>
<tr class="memdesc:a061c292c53a9836c58940100b10e2c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the relay route information.  <br /></td></tr>
<tr class="separator:a061c292c53a9836c58940100b10e2c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8173f2e03290b70d5a4f0af212e9bddc"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a8173f2e03290b70d5a4f0af212e9bddc">ClearRouteInfo</a> (bool saveValue)</td></tr>
<tr class="memdesc:a8173f2e03290b70d5a4f0af212e9bddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the route information.  <br /></td></tr>
<tr class="separator:a8173f2e03290b70d5a4f0af212e9bddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e6c9aef11ea3cf5ccdd8949a460071"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a00e6c9aef11ea3cf5ccdd8949a460071">GetSerialNumber</a> (uint32_t *pSerialNumber)</td></tr>
<tr class="memdesc:a00e6c9aef11ea3cf5ccdd8949a460071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the serial number of the modem.  <br /></td></tr>
<tr class="separator:a00e6c9aef11ea3cf5ccdd8949a460071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2945c1e9dbdec702b9c24fa1f041f25"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ab2945c1e9dbdec702b9c24fa1f041f25">GetUserID</a> (uint16_t *pUI)</td></tr>
<tr class="memdesc:ab2945c1e9dbdec702b9c24fa1f041f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the User ID of the modem.  <br /></td></tr>
<tr class="separator:ab2945c1e9dbdec702b9c24fa1f041f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bd7d9333ba76856792896e0b48b833"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a35bd7d9333ba76856792896e0b48b833">CheckCarrierSense</a> ()</td></tr>
<tr class="memdesc:a35bd7d9333ba76856792896e0b48b833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the carrier sense status (LBT). Sends @CS command and waits for response.  <br /></td></tr>
<tr class="separator:a35bd7d9333ba76856792896e0b48b833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99aee3a6ad995090f45ba66c2da7a9fe"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a99aee3a6ad995090f45ba66c2da7a9fe">GetRssiCurrentChannel</a> (int16_t *pRssi)</td></tr>
<tr class="memdesc:a99aee3a6ad995090f45ba66c2da7a9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the RSSI (Received Signal Strength Indicator) of the current channel.  <br /></td></tr>
<tr class="separator:a99aee3a6ad995090f45ba66c2da7a9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee2a353e22a1f2b6684fe7a26835d6b"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a5ee2a353e22a1f2b6684fe7a26835d6b">GetRssiCurrentChannelAsync</a> ()</td></tr>
<tr class="memdesc:a5ee2a353e22a1f2b6684fe7a26835d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the RSSI of the current channel (Asynchronous). The result will be delivered via the callback with type MU_Modem_Response::RssiCurrentChannel.  <br /></td></tr>
<tr class="separator:a5ee2a353e22a1f2b6684fe7a26835d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676b3bc11696516c1fc1ed6cd8b8534a"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a676b3bc11696516c1fc1ed6cd8b8534a">GetAllChannelsRssi</a> (int16_t *pRssiBuffer, size_t bufferSize, uint8_t *pNumRssiValues)</td></tr>
<tr class="memdesc:a676b3bc11696516c1fc1ed6cd8b8534a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets RSSI values for all channels (Synchronous). This operation takes several seconds to complete.  <br /></td></tr>
<tr class="separator:a676b3bc11696516c1fc1ed6cd8b8534a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5450979de9798b19fd18df0f9bc60a"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#aab5450979de9798b19fd18df0f9bc60a">GetAllChannelsRssiAsync</a> ()</td></tr>
<tr class="memdesc:aab5450979de9798b19fd18df0f9bc60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts getting RSSI values for all channels (Asynchronous). The result will be delivered via the callback with type MU_Modem_Response::RssiAllChannels.  <br /></td></tr>
<tr class="separator:aab5450979de9798b19fd18df0f9bc60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2dc78e8b6a400343cec344b45727e2"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#acb2dc78e8b6a400343cec344b45727e2">SetAddRssiValue</a> ()</td></tr>
<tr class="memdesc:acb2dc78e8b6a400343cec344b45727e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables appending RSSI value to received data (*DR). Sends @SI command. Used internally during initialization.  <br /></td></tr>
<tr class="separator:acb2dc78e8b6a400343cec344b45727e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7042ada21d179d3bb29c71b6db47875"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ae7042ada21d179d3bb29c71b6db47875">SoftReset</a> ()</td></tr>
<tr class="memdesc:ae7042ada21d179d3bb29c71b6db47875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a software reset of the modem. Sends @SR command.  <br /></td></tr>
<tr class="separator:ae7042ada21d179d3bb29c71b6db47875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9f2d845670cf4d4ba40b19dd390062"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a4a9f2d845670cf4d4ba40b19dd390062">SendRawCommand</a> (const char *command, char *responseBuffer, size_t bufferSize, uint32_t timeoutMs=500)</td></tr>
<tr class="memdesc:a4a9f2d845670cf4d4ba40b19dd390062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a raw command.  <br /></td></tr>
<tr class="separator:a4a9f2d845670cf4d4ba40b19dd390062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa8ef00883621cd07458fb080ed1a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a0eaa8ef00883621cd07458fb080ed1a0">HasPacket</a> ()</td></tr>
<tr class="memdesc:a0eaa8ef00883621cd07458fb080ed1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a data packet has been received and is buffered (Legacy mode).  <br /></td></tr>
<tr class="separator:a0eaa8ef00883621cd07458fb080ed1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e3a2f8fcbcf88beba4ca9026f57e00"><td class="memItemLeft" align="right" valign="top">MU_Modem_Error&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ad9e3a2f8fcbcf88beba4ca9026f57e00">GetPacket</a> (const uint8_t **ppData, uint8_t *len)</td></tr>
<tr class="memdesc:ad9e3a2f8fcbcf88beba4ca9026f57e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the buffered data packet (Legacy mode).  <br /></td></tr>
<tr class="separator:ad9e3a2f8fcbcf88beba4ca9026f57e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58b98368d24ec97d0f9a4be0d9d6b4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#ae58b98368d24ec97d0f9a4be0d9d6b4e">DeletePacket</a> ()</td></tr>
<tr class="memdesc:ae58b98368d24ec97d0f9a4be0d9d6b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the buffered data packet flag (Legacy mode).  <br /></td></tr>
<tr class="separator:ae58b98368d24ec97d0f9a4be0d9d6b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefad1a5868804dcaac32593c3880beb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#aefad1a5868804dcaac32593c3880beb4">SetAsyncCallback</a> (MU_Modem_AsyncCallback pCallback)</td></tr>
<tr class="memdesc:aefad1a5868804dcaac32593c3880beb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers or updates the asynchronous callback function.  <br /></td></tr>
<tr class="separator:aefad1a5868804dcaac32593c3880beb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSerialModemBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSerialModemBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSerialModemBase.html">SerialModemBase</a></td></tr>
<tr class="memitem:a721d7d491c855fdaf7fb6ac25cac7845 inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a721d7d491c855fdaf7fb6ac25cac7845">SerialModemBase</a> ()</td></tr>
<tr class="separator:a721d7d491c855fdaf7fb6ac25cac7845 inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92176561a6bc6194cb486b823ab4a3a5 inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a92176561a6bc6194cb486b823ab4a3a5">~SerialModemBase</a> ()=default</td></tr>
<tr class="separator:a92176561a6bc6194cb486b823ab4a3a5 inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938b49690a372fcd516ae717316dd69d inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a938b49690a372fcd516ae717316dd69d">setDebugStream</a> (Stream *debugStream)</td></tr>
<tr class="memdesc:a938b49690a372fcd516ae717316dd69d inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the debug stream.  <br /></td></tr>
<tr class="separator:a938b49690a372fcd516ae717316dd69d inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6379a71afa895ca5a974e67cfecae4ce inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a6379a71afa895ca5a974e67cfecae4ce">update</a> ()</td></tr>
<tr class="memdesc:a6379a71afa895ca5a974e67cfecae4ce inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main processing loop. Must be called frequently. Handles command queue, transmission, and response parsing.  <br /></td></tr>
<tr class="separator:a6379a71afa895ca5a974e67cfecae4ce inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2742096334dffac539fec2245d06b0e8 inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a2742096334dffac539fec2245d06b0e8">isIdle</a> () const</td></tr>
<tr class="memdesc:a2742096334dffac539fec2245d06b0e8 inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the internal engine is currently idle (no command processing).  <br /></td></tr>
<tr class="separator:a2742096334dffac539fec2245d06b0e8 inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569e64d66f8153d2ff5d1132f6113aa1 inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a569e64d66f8153d2ff5d1132f6113aa1">isLastCommandComplete</a> () const</td></tr>
<tr class="memdesc:a569e64d66f8153d2ff5d1132f6113aa1 inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the last processed command has finished. Useful for implementing synchronous wrappers.  <br /></td></tr>
<tr class="separator:a569e64d66f8153d2ff5d1132f6113aa1 inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab502aab6b4954bb68da44cf7b129459d inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#ab502aab6b4954bb68da44cf7b129459d">getLastCommandResult</a> () const</td></tr>
<tr class="memdesc:ab502aab6b4954bb68da44cf7b129459d inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the result of the last processed command.  <br /></td></tr>
<tr class="separator:ab502aab6b4954bb68da44cf7b129459d inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7febfbea4cd126a4952f0e8d9e927b95 inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a7febfbea4cd126a4952f0e8d9e927b95">getRxBuffer</a> () const</td></tr>
<tr class="memdesc:a7febfbea4cd126a4952f0e8d9e927b95 inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for the shared RX buffer.  <br /></td></tr>
<tr class="separator:a7febfbea4cd126a4952f0e8d9e927b95 inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaea338042a56fccd7e4944c1daeb6f inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#afdaea338042a56fccd7e4944c1daeb6f">getRxIndex</a> () const</td></tr>
<tr class="separator:afdaea338042a56fccd7e4944c1daeb6f inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1dc4f0421d790972c5a9e61f577207 inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a6b1dc4f0421d790972c5a9e61f577207">isQueueFull</a> () const</td></tr>
<tr class="memdesc:a6b1dc4f0421d790972c5a9e61f577207 inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the command queue is full.  <br /></td></tr>
<tr class="separator:a6b1dc4f0421d790972c5a9e61f577207 inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b88289f19d571377fcd8f39a010d1d inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#aa7b88289f19d571377fcd8f39a010d1d">isQueueEmpty</a> () const</td></tr>
<tr class="memdesc:aa7b88289f19d571377fcd8f39a010d1d inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the command queue is empty.  <br /></td></tr>
<tr class="separator:aa7b88289f19d571377fcd8f39a010d1d inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c4b2aad658674f0cf16f0b0d12475d inherit pub_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#ab9c4b2aad658674f0cf16f0b0d12475d">getQueueCount</a> () const</td></tr>
<tr class="memdesc:ab9c4b2aad658674f0cf16f0b0d12475d inherit pub_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of commands currently in the queue.  <br /></td></tr>
<tr class="separator:ab9c4b2aad658674f0cf16f0b0d12475d inherit pub_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a292d5aa2a528cb655d767235dcfc9a69"><td class="memItemLeft" align="right" valign="top">virtual ModemParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a292d5aa2a528cb655d767235dcfc9a69">parse</a> () override</td></tr>
<tr class="memdesc:a292d5aa2a528cb655d767235dcfc9a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main parser state machine step. Must use <a class="el" href="classSerialModemBase.html#af6359d9f6c622d523f0c8155190c3560">readByte()</a> and update _rxBuffer / _rxIndex.  <br /></td></tr>
<tr class="separator:a292d5aa2a528cb655d767235dcfc9a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6c35d5d02a0a11fee47ef7cdf679c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a3fe6c35d5d02a0a11fee47ef7cdf679c">onRxDataReceived</a> () override</td></tr>
<tr class="separator:a3fe6c35d5d02a0a11fee47ef7cdf679c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa70396b2505085054774bee5d57e789"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#afa70396b2505085054774bee5d57e789">onCommandComplete</a> (ModemError result) override</td></tr>
<tr class="memdesc:afa70396b2505085054774bee5d57e789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional hook called when a queued command finishes.  <br /></td></tr>
<tr class="separator:afa70396b2505085054774bee5d57e789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648cd672af4dc560d78c4bbc4bda3f00"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMU__Modem.html#a648cd672af4dc560d78c4bbc4bda3f00">getLogPrefix</a> () const override</td></tr>
<tr class="separator:a648cd672af4dc560d78c4bbc4bda3f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classSerialModemBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classSerialModemBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classSerialModemBase.html">SerialModemBase</a></td></tr>
<tr class="memitem:a90001afb9989a22eef12a7bec84c0b92 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a90001afb9989a22eef12a7bec84c0b92">initSerial</a> (Stream &amp;stream)</td></tr>
<tr class="memdesc:a90001afb9989a22eef12a7bec84c0b92 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the UART stream to use for modem communication.  <br /></td></tr>
<tr class="separator:a90001afb9989a22eef12a7bec84c0b92 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2acddc58d3a5e2de5d0bc0e35f9d87 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a6f2acddc58d3a5e2de5d0bc0e35f9d87">enqueueCommand</a> (const char *cmd, CommandType type, uint32_t timeoutMs=1000)</td></tr>
<tr class="memdesc:a6f2acddc58d3a5e2de5d0bc0e35f9d87 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a command for processing. Non-blocking.  <br /></td></tr>
<tr class="separator:a6f2acddc58d3a5e2de5d0bc0e35f9d87 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62559c5e79c97e189bc533e6e519476d inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a62559c5e79c97e189bc533e6e519476d">enqueueTxCommand</a> (const char *cmdHeader, const uint8_t *payload, uint8_t len, const char *suffix=nullptr, uint32_t timeoutMs=2000)</td></tr>
<tr class="memdesc:a62559c5e79c97e189bc533e6e519476d inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a data transmission command with payload.  <br /></td></tr>
<tr class="separator:a62559c5e79c97e189bc533e6e519476d inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c733e4185493aa3e383fe64247940c inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#aa6c733e4185493aa3e383fe64247940c">setByteValue</a> (const char *cmd, uint8_t value, bool save, const char *respPrefix, size_t respLen)</td></tr>
<tr class="memdesc:aa6c733e4185493aa3e383fe64247940c inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to set a 1-byte value (e.g., @CH0E) and verify the response.  <br /></td></tr>
<tr class="separator:aa6c733e4185493aa3e383fe64247940c inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0376336f4d71edfd68fd9e16bd2bb356 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a0376336f4d71edfd68fd9e16bd2bb356">getByteValue</a> (const char *cmd, uint8_t *pValue, const char *respPrefix, size_t respLen)</td></tr>
<tr class="memdesc:a0376336f4d71edfd68fd9e16bd2bb356 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get a 1-byte value.  <br /></td></tr>
<tr class="separator:a0376336f4d71edfd68fd9e16bd2bb356 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac70846ba74ce3fa3aef67424058a38 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a7ac70846ba74ce3fa3aef67424058a38">setBoolValue</a> (const char *baseCmd, bool enabled, bool save, const char *respPrefix)</td></tr>
<tr class="memdesc:a7ac70846ba74ce3fa3aef67424058a38 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to set a boolean value (ON/OF).  <br /></td></tr>
<tr class="separator:a7ac70846ba74ce3fa3aef67424058a38 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037bdc3e12c26a97b58d43e178d61005 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a037bdc3e12c26a97b58d43e178d61005">getBoolValue</a> (const char *cmd, bool *pValue, const char *respPrefix)</td></tr>
<tr class="memdesc:a037bdc3e12c26a97b58d43e178d61005 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to get a boolean value (ON/OF).  <br /></td></tr>
<tr class="separator:a037bdc3e12c26a97b58d43e178d61005 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5b808ae113cd332e75eb84780665a9 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a2d5b808ae113cd332e75eb84780665a9">sendRawCommand</a> (const char *command, char *responseBuffer, size_t bufferSize, uint32_t timeoutMs)</td></tr>
<tr class="memdesc:a2d5b808ae113cd332e75eb84780665a9 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a raw command string and fills the provided buffer with the response.  <br /></td></tr>
<tr class="separator:a2d5b808ae113cd332e75eb84780665a9 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ca8ae2b9ee8349a17b14a9322b567a inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a91ca8ae2b9ee8349a17b14a9322b567a">waitForSyncComplete</a> (uint32_t timeoutMs)</td></tr>
<tr class="memdesc:a91ca8ae2b9ee8349a17b14a9322b567a inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to wait for the current command to finish (Pseudo-blocking). Calls <a class="el" href="classSerialModemBase.html#a6379a71afa895ca5a974e67cfecae4ce" title="Main processing loop. Must be called frequently. Handles command queue, transmission,...">update()</a> internally.  <br /></td></tr>
<tr class="separator:a91ca8ae2b9ee8349a17b14a9322b567a inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1a5a8e4c50afee52ff9ced7ebe547c inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a9c1a5a8e4c50afee52ff9ced7ebe547c">writeString</a> (const char *str, bool printPrefix=true)</td></tr>
<tr class="separator:a9c1a5a8e4c50afee52ff9ced7ebe547c inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfe8da8ddd9f191ee0db34708cf2cd7 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#aedfe8da8ddd9f191ee0db34708cf2cd7">writeData</a> (const uint8_t *data, size_t len)</td></tr>
<tr class="separator:aedfe8da8ddd9f191ee0db34708cf2cd7 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6359d9f6c622d523f0c8155190c3560 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#af6359d9f6c622d523f0c8155190c3560">readByte</a> ()</td></tr>
<tr class="separator:af6359d9f6c622d523f0c8155190c3560 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35e6a4eb3d760c6d918f2842cb653a8 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#ac35e6a4eb3d760c6d918f2842cb653a8">unreadByte</a> (uint8_t c)</td></tr>
<tr class="separator:ac35e6a4eb3d760c6d918f2842cb653a8 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c19051d58c52cde545f5d9b7a406e2 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a72c19051d58c52cde545f5d9b7a406e2">clearUnreadByte</a> ()</td></tr>
<tr class="separator:a72c19051d58c52cde545f5d9b7a406e2 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f93fac59aa23311a1ac005d5d9248f inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#ae4f93fac59aa23311a1ac005d5d9248f">flushGarbage</a> (char keepChar=' *')</td></tr>
<tr class="separator:ae4f93fac59aa23311a1ac005d5d9248f inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014b74a55c323917455166aa4f8bf0c9 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a014b74a55c323917455166aa4f8bf0c9">startTimeout</a> (uint32_t ms)</td></tr>
<tr class="separator:a014b74a55c323917455166aa4f8bf0c9 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf4e795e387b3b1e808cd007b0e042d inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#aecf4e795e387b3b1e808cd007b0e042d">isTimeout</a> ()</td></tr>
<tr class="separator:aecf4e795e387b3b1e808cd007b0e042d inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7129047f2aaa164b385f2243248e8dc4 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a7129047f2aaa164b385f2243248e8dc4">parseResponseHex</a> (const uint8_t *buffer, size_t length, const char *prefix, uint8_t hexDigits, uint32_t *pResult)</td></tr>
<tr class="separator:a7129047f2aaa164b385f2243248e8dc4 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c31ffdb564b1a19fcf983fcf536a445 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">ModemError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a4c31ffdb564b1a19fcf983fcf536a445">parseResponseDec</a> (const uint8_t *buffer, size_t length, const char *prefix, const char *suffix, size_t suffixLen, int32_t *pResult)</td></tr>
<tr class="separator:a4c31ffdb564b1a19fcf983fcf536a445 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22317dbeea2625b628b54ab3ad80f8e7 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">virtual ModemParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a22317dbeea2625b628b54ab3ad80f8e7">parse</a> ()=0</td></tr>
<tr class="memdesc:a22317dbeea2625b628b54ab3ad80f8e7 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main parser state machine step. Must use <a class="el" href="classSerialModemBase.html#af6359d9f6c622d523f0c8155190c3560">readByte()</a> and update _rxBuffer / _rxIndex.  <br /></td></tr>
<tr class="separator:a22317dbeea2625b628b54ab3ad80f8e7 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a965cb93670f444edd823236e77ff7 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#ad5a965cb93670f444edd823236e77ff7">onRxDataReceived</a> ()=0</td></tr>
<tr class="separator:ad5a965cb93670f444edd823236e77ff7 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f23867fecd9dd11d1c7f3abaaaf6a9f inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a4f23867fecd9dd11d1c7f3abaaaf6a9f">getLogPrefix</a> () const =0</td></tr>
<tr class="separator:a4f23867fecd9dd11d1c7f3abaaaf6a9f inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092f06bfbced5de912078b554ce6eff9 inherit pro_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a092f06bfbced5de912078b554ce6eff9">onCommandComplete</a> (ModemError result)</td></tr>
<tr class="memdesc:a092f06bfbced5de912078b554ce6eff9 inherit pro_methods_classSerialModemBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional hook called when a queued command finishes.  <br /></td></tr>
<tr class="separator:a092f06bfbced5de912078b554ce6eff9 inherit pro_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_static_methods_classSerialModemBase"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classSerialModemBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classSerialModemBase.html">SerialModemBase</a></td></tr>
<tr class="memitem:a193725b12d94adcbfa185176a3d1c548 inherit pro_static_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a193725b12d94adcbfa185176a3d1c548">parseHex</a> (const uint8_t *pData, size_t len, uint32_t *pResult)</td></tr>
<tr class="separator:a193725b12d94adcbfa185176a3d1c548 inherit pro_static_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f5fa62589053128efb5f01d06b9e5 inherit pro_static_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a6e2f5fa62589053128efb5f01d06b9e5">parseDec</a> (const uint8_t *pData, size_t len, uint32_t *pResult)</td></tr>
<tr class="separator:a6e2f5fa62589053128efb5f01d06b9e5 inherit pro_static_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0601401ea0a17514bde32404c3ef39 inherit pro_static_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a2c0601401ea0a17514bde32404c3ef39">appendStr</a> (char *dest, const char *src, const char *destEnd)</td></tr>
<tr class="separator:a2c0601401ea0a17514bde32404c3ef39 inherit pro_static_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5ca2224740d2dd54b36b7e7bccdbfd inherit pro_static_methods_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a9b5ca2224740d2dd54b36b7e7bccdbfd">appendHex2</a> (char *dest, uint8_t val, const char *destEnd)</td></tr>
<tr class="separator:a9b5ca2224740d2dd54b36b7e7bccdbfd inherit pro_static_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51146522e52891aed90d67bda82f028 inherit pro_static_methods_classSerialModemBase"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:ad51146522e52891aed90d67bda82f028 inherit pro_static_methods_classSerialModemBase"><td class="memTemplItemLeft" align="right" valign="top">static char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#ad51146522e52891aed90d67bda82f028">appendStr</a> (char(&amp;destBuf)[N], char *currentPtr, const char *src)</td></tr>
<tr class="separator:ad51146522e52891aed90d67bda82f028 inherit pro_static_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c07ca4a66d4f31f44447c4fe0d80cf inherit pro_static_methods_classSerialModemBase"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a37c07ca4a66d4f31f44447c4fe0d80cf inherit pro_static_methods_classSerialModemBase"><td class="memTemplItemLeft" align="right" valign="top">static char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a37c07ca4a66d4f31f44447c4fe0d80cf">appendHex2</a> (char(&amp;destBuf)[N], char *currentPtr, uint8_t val)</td></tr>
<tr class="separator:a37c07ca4a66d4f31f44447c4fe0d80cf inherit pro_static_methods_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSerialModemBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSerialModemBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSerialModemBase.html">SerialModemBase</a></td></tr>
<tr class="memitem:a32352cff59cdde60addf40436c0436bb inherit pro_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">Stream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a32352cff59cdde60addf40436c0436bb">_uart</a> = nullptr</td></tr>
<tr class="separator:a32352cff59cdde60addf40436c0436bb inherit pro_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23917df1f4443acd603d143c55be585d inherit pro_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">Stream *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a23917df1f4443acd603d143c55be585d">_debugStream</a> = nullptr</td></tr>
<tr class="separator:a23917df1f4443acd603d143c55be585d inherit pro_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af598b0d59e607ca4ab8f7499401374a1 inherit pro_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#af598b0d59e607ca4ab8f7499401374a1">_rxBuffer</a> [<a class="el" href="classSerialModemBase.html#a446cc6fec54d1514689efb111289324f">RX_BUFFER_SIZE</a>]</td></tr>
<tr class="separator:af598b0d59e607ca4ab8f7499401374a1 inherit pro_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660cde54b0cd8a5486f8e3c2b97a81a4 inherit pro_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a660cde54b0cd8a5486f8e3c2b97a81a4">_rxIndex</a> = 0</td></tr>
<tr class="separator:a660cde54b0cd8a5486f8e3c2b97a81a4 inherit pro_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971b24470bc03cb6f1af64d0afa70ca1 inherit pro_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a971b24470bc03cb6f1af64d0afa70ca1">_oneByteBuf</a> = -1</td></tr>
<tr class="separator:a971b24470bc03cb6f1af64d0afa70ca1 inherit pro_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25739d83e21f214315ec1e3dbb9598de inherit pro_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a25739d83e21f214315ec1e3dbb9598de">_debugRxNewLine</a> = true</td></tr>
<tr class="separator:a25739d83e21f214315ec1e3dbb9598de inherit pro_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classSerialModemBase"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classSerialModemBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classSerialModemBase.html">SerialModemBase</a></td></tr>
<tr class="memitem:acec4c7a18d9bf7eb0287214c31df2fa0 inherit pro_static_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#acec4c7a18d9bf7eb0287214c31df2fa0">CD_WRITE_OK_RESPONSE</a> [] = &quot;*WR=PS&quot;</td></tr>
<tr class="separator:acec4c7a18d9bf7eb0287214c31df2fa0 inherit pro_static_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b99e1c6a57e007ffb2251de4a58ff6 inherit pro_static_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a11b99e1c6a57e007ffb2251de4a58ff6">CD_WRITE_OK_RESPONSE_LEN</a> = 6</td></tr>
<tr class="separator:a11b99e1c6a57e007ffb2251de4a58ff6 inherit pro_static_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ba8a282229b25cd00193355dc79dad inherit pro_static_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#aa7ba8a282229b25cd00193355dc79dad">CD_VAL_ON</a> [] = &quot;ON&quot;</td></tr>
<tr class="separator:aa7ba8a282229b25cd00193355dc79dad inherit pro_static_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89355ce4236571ae431f842acc497bc inherit pro_static_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#aa89355ce4236571ae431f842acc497bc">CD_VAL_OFF</a> [] = &quot;OF&quot;</td></tr>
<tr class="separator:aa89355ce4236571ae431f842acc497bc inherit pro_static_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab774f2f050e3e11d5ab3c88eaabaf916 inherit pro_static_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#ab774f2f050e3e11d5ab3c88eaabaf916">CD_CMD_WRITE_SUFFIX</a> [] = &quot;/W&quot;</td></tr>
<tr class="separator:ab774f2f050e3e11d5ab3c88eaabaf916 inherit pro_static_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446cc6fec54d1514689efb111289324f inherit pro_static_attribs_classSerialModemBase"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSerialModemBase.html#a446cc6fec54d1514689efb111289324f">RX_BUFFER_SIZE</a> = 300</td></tr>
<tr class="separator:a446cc6fec54d1514689efb111289324f inherit pro_static_attribs_classSerialModemBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides an interface to control the MU FSK modem. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a69f83020f2ccc23ce5601003b34269e8" name="a69f83020f2ccc23ce5601003b34269e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f83020f2ccc23ce5601003b34269e8">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::begin </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>pUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MU_Modem_FrequencyModel&#160;</td>
          <td class="paramname"><em>frequencyModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MU_Modem_AsyncCallback&#160;</td>
          <td class="paramname"><em>pCallback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the modem driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUart</td><td>A reference to the Stream object (e.g., Serial1). </td></tr>
    <tr><td class="paramname">frequencyModel</td><td>The frequency model of the modem. </td></tr>
    <tr><td class="paramname">pCallback</td><td>A pointer to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success. </dd></dl>

</div>
</div>
<a id="a35bd7d9333ba76856792896e0b48b833" name="a35bd7d9333ba76856792896e0b48b833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bd7d9333ba76856792896e0b48b833">&#9670;&#160;</a></span>CheckCarrierSense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::CheckCarrierSense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the carrier sense status (LBT). Sends @CS command and waits for response. </p>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok if channel is clear, MU_Modem_Error::FailLbt if busy. </dd></dl>

</div>
</div>
<a id="a8173f2e03290b70d5a4f0af212e9bddc" name="a8173f2e03290b70d5a4f0af212e9bddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8173f2e03290b70d5a4f0af212e9bddc">&#9670;&#160;</a></span>ClearRouteInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::ClearRouteInfo </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the route information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="ae58b98368d24ec97d0f9a4be0d9d6b4e" name="ae58b98368d24ec97d0f9a4be0d9d6b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58b98368d24ec97d0f9a4be0d9d6b4e">&#9670;&#160;</a></span>DeletePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MU_Modem::DeletePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the buffered data packet flag (Legacy mode). </p>

</div>
</div>
<a id="a676b3bc11696516c1fc1ed6cd8b8534a" name="a676b3bc11696516c1fc1ed6cd8b8534a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676b3bc11696516c1fc1ed6cd8b8534a">&#9670;&#160;</a></span>GetAllChannelsRssi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetAllChannelsRssi </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>pRssiBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pNumRssiValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets RSSI values for all channels (Synchronous). This operation takes several seconds to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRssiBuffer</td><td>Buffer to store RSSI values. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the buffer (number of elements). </td></tr>
    <tr><td class="paramname">pNumRssiValues</td><td>Pointer to store the number of values retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="aab5450979de9798b19fd18df0f9bc60a" name="aab5450979de9798b19fd18df0f9bc60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5450979de9798b19fd18df0f9bc60a">&#9670;&#160;</a></span>GetAllChannelsRssiAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetAllChannelsRssiAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts getting RSSI values for all channels (Asynchronous). The result will be delivered via the callback with type MU_Modem_Response::RssiAllChannels. </p>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok if the command was successfully queued. </dd></dl>

</div>
</div>
<a id="acd689f0e43071d63f4fcd91dcf083bda" name="acd689f0e43071d63f4fcd91dcf083bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd689f0e43071d63f4fcd91dcf083bda">&#9670;&#160;</a></span>GetAutoReplyRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetAutoReplyRoute </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the auto reply route setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEnabled</td><td>Pointer to a boolean to store the result (true if ON, false if OFF). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a5f55aebc00f928d3dc800f15647bf35f" name="a5f55aebc00f928d3dc800f15647bf35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f55aebc00f928d3dc800f15647bf35f">&#9670;&#160;</a></span>GetChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current frequency channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pChannel</td><td>Pointer to store the retrieved channel number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a6e447bf28d31672759cae02660bbccf7" name="a6e447bf28d31672759cae02660bbccf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e447bf28d31672759cae02660bbccf7">&#9670;&#160;</a></span>GetDestinationID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetDestinationID </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pDI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current Destination ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDI</td><td>Pointer to store the retrieved Destination ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a0e842dfdf35828a83be18b53074d3029" name="a0e842dfdf35828a83be18b53074d3029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e842dfdf35828a83be18b53074d3029">&#9670;&#160;</a></span>GetEquipmentID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetEquipmentID </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pEI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current Equipment ID (Own ID). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEI</td><td>Pointer to store the retrieved Equipment ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a78065dc4a20ad3c5cc33bc9dc9404b21" name="a78065dc4a20ad3c5cc33bc9dc9404b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78065dc4a20ad3c5cc33bc9dc9404b21">&#9670;&#160;</a></span>GetGroupID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetGroupID </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pGI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current Group ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGI</td><td>Pointer to store the retrieved Group ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a648cd672af4dc560d78c4bbc4bda3f00" name="a648cd672af4dc560d78c4bbc4bda3f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648cd672af4dc560d78c4bbc4bda3f00">&#9670;&#160;</a></span>getLogPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * MU_Modem::getLogPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classSerialModemBase.html#a4f23867fecd9dd11d1c7f3abaaaf6a9f">SerialModemBase</a>.</p>

</div>
</div>
<a id="ad9e3a2f8fcbcf88beba4ca9026f57e00" name="ad9e3a2f8fcbcf88beba4ca9026f57e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e3a2f8fcbcf88beba4ca9026f57e00">&#9670;&#160;</a></span>GetPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetPacket </td>
          <td>(</td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>ppData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the buffered data packet (Legacy mode). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppData</td><td>Output pointer to the data buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Output pointer to the length of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok if data is available, MU_Modem_Error::Fail otherwise. </dd></dl>

</div>
</div>
<a id="ac92d5ebc0102fb13cea3196a6f488617" name="ac92d5ebc0102fb13cea3196a6f488617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92d5ebc0102fb13cea3196a6f488617">&#9670;&#160;</a></span>GetPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetPower </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pPower</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current transmission power setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPower</td><td>Pointer to store the retrieved power setting (0x01 or 0x10). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a061c292c53a9836c58940100b10e2c85" name="a061c292c53a9836c58940100b10e2c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061c292c53a9836c58940100b10e2c85">&#9670;&#160;</a></span>GetRouteInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetRouteInfo </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pRouteInfoBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pNumNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the relay route information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRouteInfoBuffer</td><td>Pointer to a buffer to store the route information. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of the buffer in bytes. </td></tr>
    <tr><td class="paramname">pNumNodes</td><td>Pointer to a variable to store the number of retrieved IDs. Will be set to 0 if the route is not available ("NA"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a939cecd600fc9617c796620a1e321827" name="a939cecd600fc9617c796620a1e321827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939cecd600fc9617c796620a1e321827">&#9670;&#160;</a></span>GetRouteInfoAddMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetRouteInfoAddMode </td>
          <td>(</td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the route info add mode setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEnabled</td><td>Pointer to a boolean to store the result (true if ON, false if OFF). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a99aee3a6ad995090f45ba66c2da7a9fe" name="a99aee3a6ad995090f45ba66c2da7a9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99aee3a6ad995090f45ba66c2da7a9fe">&#9670;&#160;</a></span>GetRssiCurrentChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetRssiCurrentChannel </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>pRssi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the RSSI (Received Signal Strength Indicator) of the current channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRssi</td><td>Pointer to store the RSSI value in dBm (negative value). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a5ee2a353e22a1f2b6684fe7a26835d6b" name="a5ee2a353e22a1f2b6684fe7a26835d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee2a353e22a1f2b6684fe7a26835d6b">&#9670;&#160;</a></span>GetRssiCurrentChannelAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetRssiCurrentChannelAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the RSSI of the current channel (Asynchronous). The result will be delivered via the callback with type MU_Modem_Response::RssiCurrentChannel. </p>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok if the command was successfully queued. </dd></dl>

</div>
</div>
<a id="a00e6c9aef11ea3cf5ccdd8949a460071" name="a00e6c9aef11ea3cf5ccdd8949a460071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e6c9aef11ea3cf5ccdd8949a460071">&#9670;&#160;</a></span>GetSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetSerialNumber </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>pSerialNumber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the serial number of the modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSerialNumber</td><td>Pointer to store the retrieved serial number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="ab2945c1e9dbdec702b9c24fa1f041f25" name="ab2945c1e9dbdec702b9c24fa1f041f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2945c1e9dbdec702b9c24fa1f041f25">&#9670;&#160;</a></span>GetUserID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::GetUserID </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pUI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the User ID of the modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUI</td><td>Pointer to store the retrieved User ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a0eaa8ef00883621cd07458fb080ed1a0" name="a0eaa8ef00883621cd07458fb080ed1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaa8ef00883621cd07458fb080ed1a0">&#9670;&#160;</a></span>HasPacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MU_Modem::HasPacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a data packet has been received and is buffered (Legacy mode). </p>
<dl class="section return"><dt>Returns</dt><dd>True if a packet is available, false otherwise. </dd></dl>

</div>
</div>
<a id="afa70396b2505085054774bee5d57e789" name="afa70396b2505085054774bee5d57e789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa70396b2505085054774bee5d57e789">&#9670;&#160;</a></span>onCommandComplete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MU_Modem::onCommandComplete </td>
          <td>(</td>
          <td class="paramtype">ModemError&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional hook called when a queued command finishes. </p>

<p>Reimplemented from <a class="el" href="classSerialModemBase.html#a092f06bfbced5de912078b554ce6eff9">SerialModemBase</a>.</p>

</div>
</div>
<a id="a3fe6c35d5d02a0a11fee47ef7cdf679c" name="a3fe6c35d5d02a0a11fee47ef7cdf679c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fe6c35d5d02a0a11fee47ef7cdf679c">&#9670;&#160;</a></span>onRxDataReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MU_Modem::onRxDataReceived </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classSerialModemBase.html#ad5a965cb93670f444edd823236e77ff7">SerialModemBase</a>.</p>

</div>
</div>
<a id="a292d5aa2a528cb655d767235dcfc9a69" name="a292d5aa2a528cb655d767235dcfc9a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292d5aa2a528cb655d767235dcfc9a69">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ModemParseResult MU_Modem::parse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Main parser state machine step. Must use <a class="el" href="classSerialModemBase.html#af6359d9f6c622d523f0c8155190c3560">readByte()</a> and update _rxBuffer / _rxIndex. </p>
<dl class="section return"><dt>Returns</dt><dd>Current status of parsing. </dd></dl>

<p>Implements <a class="el" href="classSerialModemBase.html#a22317dbeea2625b628b54ab3ad80f8e7">SerialModemBase</a>.</p>

</div>
</div>
<a id="a4a9f2d845670cf4d4ba40b19dd390062" name="a4a9f2d845670cf4d4ba40b19dd390062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9f2d845670cf4d4ba40b19dd390062">&#9670;&#160;</a></span>SendRawCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SendRawCommand </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>responseBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeoutMs</em> = <code>500</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a raw command. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The null-terminated command string to send. </td></tr>
    <tr><td class="paramname">responseBuffer</td><td>Buffer to store the raw response line from the modem (excluding CRLF). </td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the responseBuffer. </td></tr>
    <tr><td class="paramname">timeoutMs</td><td>Timeout in milliseconds to wait for the response. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, MU_Modem_Error::Timeout if no response, MU_Modem_Error::Busy if another operation is in progress, MU_Modem_Error::BufferTooSmall if the buffer is too small, MU_Modem_Error::Fail on other errors. </dd></dl>

</div>
</div>
<a id="acb2dc78e8b6a400343cec344b45727e2" name="acb2dc78e8b6a400343cec344b45727e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2dc78e8b6a400343cec344b45727e2">&#9670;&#160;</a></span>SetAddRssiValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetAddRssiValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables appending RSSI value to received data (*DR). Sends @SI command. Used internally during initialization. </p>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success. </dd></dl>

</div>
</div>
<a id="aefad1a5868804dcaac32593c3880beb4" name="aefad1a5868804dcaac32593c3880beb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefad1a5868804dcaac32593c3880beb4">&#9670;&#160;</a></span>SetAsyncCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MU_Modem::SetAsyncCallback </td>
          <td>(</td>
          <td class="paramtype">MU_Modem_AsyncCallback&#160;</td>
          <td class="paramname"><em>pCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers or updates the asynchronous callback function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pCallback</td><td>The callback function to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02f7989b9881a44f478ea4f3866e6042" name="a02f7989b9881a44f478ea4f3866e6042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f7989b9881a44f478ea4f3866e6042">&#9670;&#160;</a></span>SetAutoReplyRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetAutoReplyRoute </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the auto reply route setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>If true, enables the feature (@RR ON). When a data packet with route information is received, the modem automatically generates a return route and writes it to the route register. If false, disables the feature (@RR OF). </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a53bb2018225a6207d8a774eb5ce1220c" name="a53bb2018225a6207d8a774eb5ce1220c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bb2018225a6207d8a774eb5ce1220c">&#9670;&#160;</a></span>SetBaudRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetBaudRate </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the UART baud rate of the modem. The change is applied immediately after the modem sends its response. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function does NOT reconfigure the host's UART. The caller MUST reconfigure the host's UART baud rate (e.g., via <code>Serial.begin()</code> or <code>Serial.updateBaudRate()</code>) immediately after this function returns <code>Ok</code>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudRate</td><td>The target baud rate. Supported values: 1200, 2400, 4800, 9600, 19200, 38400, 57600. </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a6b7eba13080e003515573911fcf5dc72" name="a6b7eba13080e003515573911fcf5dc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7eba13080e003515573911fcf5dc72">&#9670;&#160;</a></span>SetChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetChannel </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the frequency channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel number to set. Valid range depends on the frequency model. </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a76d2dcbd26f5e78f8a831875124bfaa4" name="a76d2dcbd26f5e78f8a831875124bfaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d2dcbd26f5e78f8a831875124bfaa4">&#9670;&#160;</a></span>SetDestinationID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetDestinationID </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>di</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Destination ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">di</td><td>The Destination ID to set (0x00 - 0xFF). </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="ac0a1f04cce8a4ec97c5630f799197829" name="ac0a1f04cce8a4ec97c5630f799197829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a1f04cce8a4ec97c5630f799197829">&#9670;&#160;</a></span>SetEquipmentID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetEquipmentID </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Equipment ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ei</td><td>The Equipment ID to set (0x00 - 0xFF). </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="acf73a7d66cebcfecc6c1a1f3705cefdc" name="acf73a7d66cebcfecc6c1a1f3705cefdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf73a7d66cebcfecc6c1a1f3705cefdc">&#9670;&#160;</a></span>SetGroupID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetGroupID </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Group ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gi</td><td>The Group ID to set (0x00 - 0xFF). </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="ad75244d356cac51e2d1f13bc86d7265f" name="ad75244d356cac51e2d1f13bc86d7265f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75244d356cac51e2d1f13bc86d7265f">&#9670;&#160;</a></span>setPacketBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MU_Modem::setPacketBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets an external buffer to store received packets for <a class="el" href="classMU__Modem.html#a0eaa8ef00883621cd07458fb080ed1a0" title="Checks if a data packet has been received and is buffered (Legacy mode).">HasPacket()</a>/GetPacket(). Not required if using Async Callback only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the user-allocated buffer. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the buffer (should be at least MU_MAX_PAYLOAD_LEN). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6670c9ecc6d112775659a57f6b47c39" name="ae6670c9ecc6d112775659a57f6b47c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6670c9ecc6d112775659a57f6b47c39">&#9670;&#160;</a></span>SetPower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetPower </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the transmission power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>The power setting to set (0x01 for 1mW, 0x10 for 10mW). </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="add62e145605088cd858a71b523f92bba" name="add62e145605088cd858a71b523f92bba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add62e145605088cd858a71b523f92bba">&#9670;&#160;</a></span>SetRouteInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetRouteInfo </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pRouteInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the relay route information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRouteInfo</td><td>Pointer to an array containing the route information (relay station IDs and destination ID). </td></tr>
    <tr><td class="paramname">numNodes</td><td>The number of IDs in the route information (1 &lt;= numNodes &lt;= 11). </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="af2a3911d2ae1d8a2746c84b6e772091a" name="af2a3911d2ae1d8a2746c84b6e772091a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a3911d2ae1d8a2746c84b6e772091a">&#9670;&#160;</a></span>SetRouteInfoAddMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SetRouteInfoAddMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the route info add mode setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True to enable (@RI ON), false to disable (@RI OF). </td></tr>
    <tr><td class="paramname">saveValue</td><td>If true, saves the setting to non-volatile memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, or an error code on failure. </dd></dl>

</div>
</div>
<a id="ae7042ada21d179d3bb29c71b6db47875" name="ae7042ada21d179d3bb29c71b6db47875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7042ada21d179d3bb29c71b6db47875">&#9670;&#160;</a></span>SoftReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::SoftReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a software reset of the modem. Sends @SR command. </p>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success. </dd></dl>

</div>
</div>
<a id="a4073269482792c7909eb3f063e92328e" name="a4073269482792c7909eb3f063e92328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4073269482792c7909eb3f063e92328e">&#9670;&#160;</a></span>TransmitData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::TransmitData </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRouteRegister</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a data packet (Synchronous/Blocking). Queues the command and waits for completion. Checks for LBT error (*IR=01) for a short period after command acceptance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMsg</td><td>Pointer to the data buffer to transmit. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data in bytes. </td></tr>
    <tr><td class="paramname">useRouteRegister</td><td>If true, appends the /R option to use the route register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok on success, MU_Modem_Error::FailLbt if busy. </dd></dl>

</div>
</div>
<a id="a6631e32d207b6855fe2a8e48b20ad988" name="a6631e32d207b6855fe2a8e48b20ad988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6631e32d207b6855fe2a8e48b20ad988">&#9670;&#160;</a></span>TransmitDataAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MU_Modem_Error MU_Modem::TransmitDataAsync </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>pMsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRouteRegister</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a data packet (Asynchronous/Non-blocking). Queues the command and returns immediately. Completion result (TxComplete/TxFailed) is notified via callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMsg</td><td>Pointer to the data buffer to transmit. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the data in bytes. </td></tr>
    <tr><td class="paramname">useRouteRegister</td><td>If true, appends the /R option to use the route register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MU_Modem_Error::Ok if command accepted. </dd></dl>

</div>
</div>
<a id="a093205206ee7f99b2cb8a7acb082e6f5" name="a093205206ee7f99b2cb8a7acb082e6f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093205206ee7f99b2cb8a7acb082e6f5">&#9670;&#160;</a></span>Work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MU_Modem::Work </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main processing loop (Delegates to <a class="el" href="classSerialModemBase.html#a6379a71afa895ca5a974e67cfecae4ce" title="Main processing loop. Must be called frequently. Handles command queue, transmission,...">SerialModemBase::update</a>). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="MU__Modem_8h_source.html">MU_Modem.h</a></li>
<li>src/MU_Modem.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
